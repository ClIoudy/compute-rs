    fn get_wgpu_buffer(&self, buffer: &Buffer) -> wgpu::Buffer {
        self.device.create_buffer(
            &wgpu::BufferDescriptor {
                label: None,
                size: 0,
                usage: wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::STORAGE,
                mapped_at_creation: false
            }
        )
    }

    fn create_bind_group_entry(&mut self, buffer: &'a Buffer) -> wgpu::BindGroupEntry {
        let wgpu_buffer = buffer.wgpu_buffer.as_ref().unwrap();

        wgpu::BindGroupEntry {
            binding: buffer.binding,
            resource: wgpu_buffer.as_entire_binding(),
        }
        
    }

    fn create_bind_group_layout_entry(&self, buffer: &Buffer) -> wgpu::BindGroupLayoutEntry {
        wgpu::BindGroupLayoutEntry {
            binding: buffer.binding,
            visibility: wgpu::ShaderStages::COMPUTE,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Storage { read_only: false }, 
                has_dynamic_offset: false, 
                min_binding_size: std::num::NonZeroU64::new(0) 
            },
            count: None,
        }
    }

    fn create_bind_group_layout(&mut self) {
        self.bind_group_layout = Some(self.device.create_bind_group_layout(
            &wgpu::BindGroupLayoutDescriptor { label: None, entries: &self.bind_group_layout_entries }
        ));
    }

    fn create_bind_group(&mut self) {
        if self.pipline_layout.is_none() {
            self.create_pipeline_layout()
        }
        
        self.bind_group = Some(self.device.create_bind_group(
            &wgpu::BindGroupDescriptor { label: None, layout: self.bind_group_layout.as_ref().unwrap(), entries: &self.bind_group_entries }
        ));
    }

    fn create_pipeline_layout(&mut self) {        
        if let Some(bind_group_layout) = self.bind_group_layout.as_ref() {
            self.pipline_layout = Some(self.device.create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor { label: None, bind_group_layouts: &[bind_group_layout], push_constant_ranges: &[] }
            ));
        } else {
            self.pipline_layout = Some(self.device.create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor { label: None, bind_group_layouts: &[], push_constant_ranges: &[] }
            ));
        }
    }

-----------------------------






        let staging_buffer = self.device.create_buffer_init(
            &wgpu::util::BufferInitDescriptor {
                label: None,
                contents: &self.buffers[0].data,
                usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_SRC,
            }
        );

        let readback_buffer = self.device.create_buffer(
            &wgpu::BufferDescriptor {
                label: None,
                size: self.buffers[0].data.len() as wgpu::BufferAddress,
                usage: wgpu::BufferUsages::MAP_READ | wgpu::BufferUsages::COPY_DST,
                mapped_at_creation: false,
            }
        );

        let bind_group_layout = self.device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: None,
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    count: None,
                    visibility: wgpu::ShaderStages::COMPUTE,
                    ty: wgpu::BindingType::Buffer {
                        has_dynamic_offset: false,
                        min_binding_size: Some(std::num::NonZeroU64::new(self.buffers[0].data.len() as u64).unwrap()),
                        ty: wgpu::BufferBindingType::Storage { read_only: false },
                    },
                },
            ],
        });
    

        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: None,
            layout: &bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: staging_buffer.as_entire_binding(),
                }
            ],
        });

        let pipeline_layout = self.device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: None,
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });



        -------------------------------------



  if self.pipline_layout.is_none() {

            if self.bind_group_layout.is_none() {
                self.bind_group_layout = Some(self.device.create_bind_group_layout(
                    &wgpu::BindGroupLayoutDescriptor { label: None, entries: self.bind_group_layout_entries.as_slice() }
                ));
            }

            self.pipline_layout = Some(self.device.create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: None,
                    bind_group_layouts: &[self.bind_group_layout.as_ref().unwrap()],
                    push_constant_ranges: &[],
                }
            ));
        }
        
        if self.bind_group.is_none() {
            self.bind_group = Some(self.device.create_bind_group(
                &wgpu::BindGroupDescriptor { 
                    label: None, 
                    layout: self.bind_group_layout.as_ref().unwrap(), 
                    entries: self.bind_group_entries.as_slice() }
            ));
        }


        let compute_pipeline = self.device.create_compute_pipeline(
            &wgpu::ComputePipelineDescriptor { 
                label: Some(entry_point),
                layout: Some(self.pipline_layout.as_ref().unwrap()),
                module: &self.module,  
                entry_point 
            }
        );

        let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

        {
            let mut cpass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor { label: None, timestamp_writes: None });
            cpass.set_pipeline(&compute_pipeline);
            cpass.set_bind_group(0, self.bind_group.as_ref().unwrap(), &[]);
            cpass.dispatch_workgroups(x, y, z)
        }


        // encoder.copy_buffer_to_buffer(
        //     &staging_buffer, 0,
        //     &readback_buffer, 0,
        //     staging_buffer.size(),
        // );

        // self.queue.submit(Some(encoder.finish()));
        // self.device.poll(wgpu::Maintain::Wait);
        // let buffer_slice = readback_buffer.slice(..);
        // buffer_slice.map_async(wgpu::MapMode::Read, |x| () );
        // self.device.poll(wgpu::Maintain::Wait);

        // let data = buffer_slice.get_mapped_range().to_vec();


        // self.buffers[0].data = data.clone();